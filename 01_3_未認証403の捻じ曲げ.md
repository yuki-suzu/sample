「すべてが PUT メソッド」という方針は、HTTP標準（GETは参照、PUTは更新）から逸脱しており、ブラウザのキャッシュやプロキシの挙動などでデメリットが多いですが、**現場の制約であれば技術的に解決するしかありません**。

**問題の核心:**
CSRFチェックは「未認証かどうか」に関わらず、PUT/POSTリクエストに対して機械的に行われます。未ログインユーザーはCSRFトークンを持っていないため、PUTを投げると**認証フィルター(401)に到達する前に、CSRFフィルターで403エラーになってしまいます**。

**解決策:**
**「未ログインユーザーがCSRFエラー（403）になった場合は、それを401（未認証）として扱い、ログインフローへ流す」** という特例処理を実装します。

既存の `JsonAccessDeniedHandler` を少し改造するだけで対応可能です。

---

### 実装修正：JsonAccessDeniedHandler.java

このハンドラ内で、「ユーザーが未ログイン（Anonymous）」かどうかを判定し、そうであれば `JsonAuthenticationEntryPoint`（401処理）に処理を委譲します。

```java
package com.example.trustap.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.context.annotation.Lazy;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.csrf.CsrfException;
import org.springframework.security.web.csrf.InvalidCsrfTokenException;
import org.springframework.security.web.csrf.MissingCsrfTokenException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@Component
public class JsonAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper;
    private final JsonAuthenticationEntryPoint authenticationEntryPoint;

    // 循環参照を防ぐために @Lazy を推奨
    public JsonAccessDeniedHandler(ObjectMapper objectMapper, 
                                   @Lazy JsonAuthenticationEntryPoint authenticationEntryPoint) {
        this.objectMapper = objectMapper;
        this.authenticationEntryPoint = authenticationEntryPoint;
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        
        // 現在の認証情報を取得
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        // 【回避策】
        // CSRFエラーであり、かつ「ユーザーが未ログイン(Anonymous)」の場合
        // -> これは「攻撃」ではなく「初回のアクセス」とみなして、401処理へ委譲する
        if (isCsrfException(accessDeniedException) && isAnonymous(auth)) {
            // 401ハンドラ (EntryPoint) を呼び出して終了
            authenticationEntryPoint.commence(request, response, 
                new InsufficientAuthenticationException("CSRF token missing for anonymous user", accessDeniedException));
            return;
        }

        // --- 通常の 403 処理 (ログイン済みだが権限がない場合など) ---

        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        Map<String, String> body = Map.of(
            "error", "Forbidden",
            "message", "このリソースへのアクセス権限がありません。"
        );

        response.getWriter().write(objectMapper.writeValueAsString(body));
    }

    /**
     * 未ログインユーザーかどうかを判定
     */
    private boolean isAnonymous(Authentication auth) {
        return auth == null || auth instanceof AnonymousAuthenticationToken;
    }

    /**
     * エラー原因がCSRF関連かどうかを判定
     */
    private boolean isCsrfException(AccessDeniedException ex) {
        return ex instanceof MissingCsrfTokenException || ex instanceof InvalidCsrfTokenException || ex instanceof CsrfException;
    }
}

```

### 解説

1. **処理の委譲 (Delegate):**
* `AccessDeniedHandler` (403担当) の中で条件判定を行い、条件に合致したら `JsonAuthenticationEntryPoint` (401担当) の `commence` メソッドを呼び出しています。
* これにより、`{"loginUrl": "..."}` というJSONが返され、Angular側は正常にリダイレクト処理を行えます。


2. **条件判定 (`isAnonymous`):**
* `auth instanceof AnonymousAuthenticationToken` は、Spring Security における「未ログインユーザー」を表すトークンです。
* ログイン済みのユーザーが CSRF トークンを忘れた場合は、これまで通り 403 (Forbidden) になります（これは正しいセキュリティ挙動です）。


3. **`@Lazy`:**
* `SecurityConfig` 内で `EntryPoint` と `AccessDeniedHandler` が相互に依存関係になりやすいため、コンストラクタインジェクション時に `@Lazy` をつけることで循環参照エラーを防いでいます。



### SecurityConfig.java への変更

変更はありません。前回追加した `.accessDeniedHandler(accessDeniedHandler)` がそのまま機能します。

### まとめ

この修正を入れることで、以下の挙動になります。

* **未ログイン時:** PUT `/api/hogehoge` → CSRFエラー(403)検知 → 未ログインなので **401** に変換 → Angularがログインへ誘導（成功）
* **ログイン済み時:** PUT `/api/hogehoge` (CSRFなし) → **403** (エラー)
* **ログイン済み時:** PUT `/api/hogehoge` (CSRFあり・権限なし) → **403** (エラー)

これで「すべてPUT」という特殊な環境下でも、セキュアかつスムーズなログインフローを実現できます。
